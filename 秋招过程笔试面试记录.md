## 项目

#### 如何封装组件

1. 使用propsType进行代码鲁棒性检测 对用户的输入进行合理的检测以及默认值的赋予
2. 输出规范的接口文档，对参数和类型进行说明 对一些变化的参数进行接口暴露
3. 抽离接口层和前端







## CSS

###### 1.元素的 margin 和 padding 设置为百分比时，基准为包含块的 width



###### 2.跨域问题 

https://www.nowcoder.com/questionTerminal/a75606a328364bf5b62056e9f4fb0061?page=1&onlyReference=false#:~:text=css%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD,%E7%94%A8B%E7%AB%99%E7%82%B9%E7%9A%84%E6%A0%B7%E5%BC%8Fd



###### 3.background-size: contain

- background-size: contain;

- background-size: cover;
- background-size: 100%;





## JS

###### 1.箭头函数没有prototype 也没有artuments等参数



###### 2.this指向

```js
function test(){
    this.flag = false,
    this.change = ()=>{
        this.flag = true
        console.log(button.flag);
    }
}

const button = new test()

setTimeout(()=>{
    button.change() //true
})

```



###### 3. async await

```js
(
    async function fn(){
        console.log(1);
        setTimeout(()=>{
            console.log(2);
        },0)
        await new Promise((resolve,reject)=>{
            console.log(3);
            resolve(1);
        }).then(()=>{
            console.log(4);
        })
        console.log(5);
    }
)()
// 1 3 4 5 2
```



###### 4.类型判断

```js
console.log(Number(2) === 2); //true
console.log(Boolean(false) === Boolean(false));  //true
console.log(new Number(2) === 2); //false
console.log(new Boolean(false) === false); //false
console.log(String(2) === '2'); //true
console.log([] === []); //false
console.log(NaN === NaN); // false

```





###### 5.generator



```js
var b = 9
var a =function*(){
    b = yield(10)
    return 11
}
var f = a()
console.log(f.next().value,b,f.next().value,b); //10 9 11 undefined
```



###### 6.数据处理 提升value

```js
const valueRaise = (item,k='value')=>{
    if(typeof item != 'object' || item == null) return item
    if(Array.isArray(item)){
        for(let o of item){
            o = valueRaise(o,k)
            if(o[k]){
                o = o[k]
            }
        }
    }else{
        for(let o of Object.keys(item)){
            item[o] = valueRaise(item[o],k)
            if(item[o][k]){
                item[o] = item[o][k]
            }
        }
    }
    return item
}

const data ={
    "a1":{
        "b1":{
            "value":"I will raise"
        },
        "b2":{
            "c1":{
                "value":"I will raise"
            }
        }
    },
    "a2":[
        {
            "b1":{
                "value":"I will raise"
            }
        },
        {
            "b1":{
                "c1":{
                    "value":"I will raise"
                }
            }
        }
    ]
}

console.dir(valueRaise(data));

```





###### 原型链

```js
console.log(Array.prototype === Object.prototype);
console.log(Array.prototype.__proto === Object.prototype); //true
console.log([].prototype === Array.prototype); 
console.log([].__proto === Array.prototype); //true
```









## 计算机基础



###### 1.路由器工作在哪一层

![这里写图片描述](https://img-blog.csdn.net/20170822224933262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

物理层：集线器
数据链路层：交换机，中继器
网络层：**路由器**，防火墙，防毒墙，IDS，IPS，VPN





###### 2.Hash冲突的时候4种解决方案



1. 开放定址法 （线性探测再散列、 平方探测再散列、 随机探测再散列）
2. 再哈希法
3. 链地址法
4. 建立一个公共溢出区

https://juejin.cn/post/6844904057891454989







## 算法



1. 一定要看清楚题目 并且有一定思路才开始编写代码！！！
2. 注意边界条件 不要仅限于给你看的用例  ！！  先要自己枚举下各种情况！  比如常见的 相同？ 或者相反？ 是否有死循环？ 边界？









## 基础选择题

###### 1.str.search 可以传入子串或者正则表达式来进行搜索



###### 2.![img](https://uploadfiles.nowcoder.com/images/20190903/8018242_1567479495575_D3936A1FC6EBC59323A9A311B6076ABF)



###### 3.关于try catch break label的使用

https://www.nowcoder.com/test/question/done?tid=59935790&qid=2203208#summary



###### 4.关于delete 使用

https://www.nowcoder.com/test/question/done?tid=59935790&qid=2203205#summary



###### 5.async await

```js
async function foo(){
    console.log(2);
    console.log(await Promise.resolve(8));
    console.log(9);
    console.log(await Promise.resolve(18));
    console.log(19);
}
async function bar(){
    console.log(4);
    console.log(await 6);
    console.log(7);
}
console.log(1);
foo()
console.log(3);
bar()
console.log(5);
// 1 2 3 4 5 8 9 6 7 18 19
```



###### 6. OSI各层协议

```js
vlan 链路层
IP 网络层
ICMP 网络层
TCP 传输层
```





###### 7.ES6 module

[好文讲es6和commonJS](https://juejin.cn/post/6844904080955932680)

```js
ES6 模块 加载过程
ES6 模块的加载过程分为三步：
1. 查找，下载，解析，构建所有模块实例。
ES6 模块会在程序开始前先根据模块关系查找到所有模块，生成一个无环关系图，并将所有模块实例都创建好，这种方式天然地避免了循环引用的问题，当然也有模块加载缓存，重复 import 同一个模块，只会执行一次代码。


2. 在内存中腾出空间给即将 export 的内容（此时尚未写入 export value）。然后使 import 和 export 指向内存中的这些空间，这个过程也叫连接。
这一步完成的工作是 living binding import export，借助下面的例子来帮助理解。
// counter.js
let count = 1;

function increment () {
  count++;
}

module.exports = {
  count,
  increment
}

// main.js
const counter = require('counter.cjs');

counter.increment();
console.log(counter.count); // 1
复制代码
上面 CommonJS 的例子执行结果很好理解，修改 count++ 修改的是模块内的基础数据类型变量，不会改变 exports.count，所以打印结果认为 1。
// counter.mjs
export let count = 1;

export function increment () {
  count++;
}

// main.mjs
import { increment, count } from './counter.mjs'

increment();
console.log(count); // 2
复制代码
从结果上看使用 ES6 模块的写法，当 export 的变量被修改时，会影响 import 的结果。这个功能的实现就是 living binding，具体规范底层如何实现可以暂时不管，但是知道 living binding 比网上文章描述为 "ES6 模块输出的是值的引用" 更好理解。
更接近 ES6 模块的 CommonJS 代码可以是下面这样：
exports.counter = 1;

exports.increment = function () {
    exports.counter++;
}
复制代码


3. 运行模块代码将变量的实际值填写在第二步生成的空间中。
到第三步，会基于第一步生成的无环图进行深度优先后遍历填值，如果这个过程中访问了尚未初始化完成的空间，会抛出异常。
// a.mjs
export const a1 = true;
import * as b from './b.mjs';
export const a2 = true;

// b.mjs
import { a1, a2 } from './a.mjs'
console.log(a1, a2);
复制代码
上面的例子会在运行时抛出异常 ReferenceError: Cannot access 'a1' before initialization。如果改成 import * as a from 'a.mjs' 可以看到 a 模块中 export 的对象已经占好坑了。
// b.mjs
import * as a from './a.mjs'
console.log(a);
复制代码
将输出 { a1: <uninitialized>, a2: <uninitialized> } 可以看出，ES6 模块为 export 的变量预留了空间，不过尚未赋值。这里和 CommonJS 不一样，CommonJS 到这里是知道 a1 为 true, a2 为 undefined
除此之外，我们还能推导出一些 ES6 模块和 CommonJS 的差异点：

CommonJS 可以在运行时使用变量进行 require, 例如 require(path.join('xxxx', 'xxx.js'))，而静态 import 语法（还有动态 import，返回 Promise）不行，因为 ES6 模块会先解析所有模块再执行代码。



require 会将完整的 exports 对象引入，import 可以只 import 部分必要的内容，这也是为什么使用 Tree Shaking 时必须使用 ES6 模块 的写法。
import 另一个模块没有 export 的变量，在代码执行前就会报错，而 CommonJS 是在模块运行时才报错。

```







###### 8.object的key值只能是string Symbol ，传入Object会转换成[object Object]

```js
let a ={a:30}
let b = {b:10}
let obj = {a:10}
obj[b] = 20
console.log(obj[a]);//20
// obj => { a: 10, '[object Object]': 20 }
```



###### 9.active hover focus

:hover[选择器](https://so.csdn.net/so/search?q=选择器&spm=1001.2101.3001.7020)：当鼠标悬停在所指定的元素上时所使用的样式；
:active选择器：当所指定的元素处于激活状态（鼠标在元素上按下还没有松开）时所使用的样式；
:focus选择器：当元素获得光标焦点时使用的样式，主要用在[文本框](https://so.csdn.net/so/search?q=文本框&spm=1001.2101.3001.7020)输入文字时使用；





###### 10.块内函数声明

![img](https://uploadfiles.nowcoder.com/images/20180329/5366362_1522292834342_6879D7CE5D49039657D908C22C2CF7A1)









































































## CodeTop

#### [415. 字符串相加](https://leetcode.cn/problems/add-strings/)

```js
var addStrings = function(num1, num2) {
    let i = num1.length-1
    let j = num2.length-1
    let add = 0
    let res = []
    while(i>=0 || j>=0 || add>0){
        let a = i>=0 ? Number(num1[i]) : 0
        let b = j>=0 ? Number(num2[j]) : 0
        let sum = a+b+add
        add = Math.floor(sum/10)
        res.push(sum%10)
        i--
        j--
    }
    return res.reverse().join('')
};
```

#### [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

```js
var zigzagLevelOrder = function(root) {
    if(!root) return []
    let res = []
    let times = 0
    let node = root
    let queue = [node]
    while(queue.length>0){
        let size = queue.length
        let cur = []
        for(let i=0;i<size;i++){
            if(times % 2 === 0){
                let temp = queue.shift()
                if(temp){
                    cur.push(temp.val)
                    queue.push(temp.left)
                    queue.push(temp.right)
                }
            }else{
                let temp = queue.shift()
                if(temp){
                    cur.push(temp.val)
                    queue.push(temp.right)
                    queue.push(temp.left)
                }
            }
        }
        times++
        queue.reverse()
        if(cur.length>0) res.push(cur)
    }
    return res
};
```





#### [137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)

```js
var singleNumber = function(nums) {
    let res = 0
    for(let i=0;i<32;i++){
        let total = 0 
        for(const num of nums){
            total += ((num>>i)&1)
        }
        if(total % 3){
            res |= (1<<i)
        }
    }
    return res
};
//还可以使用门电路组合  用a,b两个数来保存  接着根据 00 => 01 => 10 =>00 去进行改变
```











## 面试英文自我介绍

```
Good afternoon,thank you for giving me the opportunity to have this interview.
My name is huanghualian.My major is Internet of things. My hobbies,such as playing basketball,browsing front end's blog,

First i am intersed in playing basketball, i am a member of college basktetball team, so i will play basketball with friends in my spare time. And i aslo like browsering some tech blog and vedio, mainly about front end, i think i learn a lot from experiences shared by other coders, Finally,some other interests such listening to music、watching TV series,going Travel, 


自我介绍
hello,i am hhl,i am studying in a new college called shenzhen technology university.And my major is Internet of Things. During college i passed cet4、6 and got a scholarship. i did an internship at Tencent for 5 months,so i am familiar with some developments tools liked git. My jod during intership is to write React and package it into Wechat minApp and moblie h5 through frame of Taro. In my spare time, i like all kinds of sports especially playing basketball. Thank you for giving this oppotunity to attend this interview
```

