## 项目

#### 如何封装组件

1. 使用propsType进行代码鲁棒性检测 对用户的输入进行合理的检测以及默认值的赋予
2. 输出规范的接口文档，对参数和类型进行说明 对一些变化的参数进行接口暴露
3. 抽离接口层和前端







## CSS

###### 1.元素的 margin 和 padding 设置为百分比时，基准为包含块的 width



###### 2.跨域问题 

https://www.nowcoder.com/questionTerminal/a75606a328364bf5b62056e9f4fb0061?page=1&onlyReference=false#:~:text=css%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD,%E7%94%A8B%E7%AB%99%E7%82%B9%E7%9A%84%E6%A0%B7%E5%BC%8Fd





## 计算机基础



###### 1.路由器工作在哪一层

![这里写图片描述](https://img-blog.csdn.net/20170822224933262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

物理层：集线器
数据链路层：交换机，中继器
网络层：**路由器**，防火墙，防毒墙，IDS，IPS，VPN





###### 2.Hash冲突的时候4种解决方案



1. 开放定址法 （线性探测再散列、 平方探测再散列、 随机探测再散列）
2. 再哈希法
3. 链地址法
4. 建立一个公共溢出区

https://juejin.cn/post/6844904057891454989







## 算法



1. 一定要看清楚题目 并且有一定思路才开始编写代码！！！
2. 注意边界条件 不要仅限于给你看的用例  ！！  先要自己枚举下各种情况！  比如常见的 相同？ 或者相反？ 是否有死循环？ 边界？







## CodeTop

#### [415. 字符串相加](https://leetcode.cn/problems/add-strings/)

```js
var addStrings = function(num1, num2) {
    let i = num1.length-1
    let j = num2.length-1
    let add = 0
    let res = []
    while(i>=0 || j>=0 || add>0){
        let a = i>=0 ? Number(num1[i]) : 0
        let b = j>=0 ? Number(num2[j]) : 0
        let sum = a+b+add
        add = Math.floor(sum/10)
        res.push(sum%10)
        i--
        j--
    }
    return res.reverse().join('')
};
```

#### [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

```js
var zigzagLevelOrder = function(root) {
    if(!root) return []
    let res = []
    let times = 0
    let node = root
    let queue = [node]
    while(queue.length>0){
        let size = queue.length
        let cur = []
        for(let i=0;i<size;i++){
            if(times % 2 === 0){
                let temp = queue.shift()
                if(temp){
                    cur.push(temp.val)
                    queue.push(temp.left)
                    queue.push(temp.right)
                }
            }else{
                let temp = queue.shift()
                if(temp){
                    cur.push(temp.val)
                    queue.push(temp.right)
                    queue.push(temp.left)
                }
            }
        }
        times++
        queue.reverse()
        if(cur.length>0) res.push(cur)
    }
    return res
};
```

