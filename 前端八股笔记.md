# HTML

### 行内元素、块级元素

块级元素：div ul table form ol  audio video Footer

行内元素：a span img strong  buttom input select label 

空元素：br hr img input link meta

### 行内元素与块级元素的区别？

```
HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。

（1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。
（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。
（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei
     ght），设置 margin 和 padding 的上下不会对其他元素产生影响。
```



### HTML5 有哪些新特性、移除了那些元素？

新增： 

1. WebWorker、Websocket
2. 一些语义化的标签 Footer Header
3. canvas画布 
4. localStorage和sessionStorage
5. 用于媒介回放的 video 和 audio 元素;
6. 新的文档属性 document.visibilityState

删除：

1. big 、basefont、font等纯表现的元素
2. 对可用性产生负面影响的元素 如 frame frameset

### HTML语义化

1. 更方便开发者阅读 提高开发效率（即使没有CSS的情况下） 例如b 和strong 一个只是单纯的样式强调 一个会重读
2. 搜索引擎爬虫也依赖于HTML标记来确定上下文和各关键字的权重，利于SEO
3. 用正确的标签做正确的事情
4. 使阅读源码的同学更容易理解和分块
5. 对一些有障碍的人士使用仪器阅读



### 前端需要注意哪些 SEO ？

1. TDK合理的设置 方便爬虫爬取收录
2. 语义化标签  爬虫也依赖于HTML标记来确定上下文和各关键字的权重
3. 重要的HTML代码放最前面
4. 嵌套层级不要太深
5. 重要的内容不要用js输出
6. 提高网站的速度
7. 非装饰性的img一定要加上alt



### iframe 有那些缺点？

```
 iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。

 主要缺点有：

 （1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才
      会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。
 （2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。
 （3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
 （4） 浏览器的后退按钮失效。
 （5） 小型的移动设备无法完全显示框架。
```



### Label 的作用是什么？是怎么用的？

```
 label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。

 <label for="Name">Number:</label>
 <input type=“text“ name="Name" id="Name"/>
```



#### 如何实现浏览器内多个标签页之间的通信?

```
 （1）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。

 （2）使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标
     签页之间的双向通行。

 （3）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触
     发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；

 （4）如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。
```



### 实现不使用 border 画出 1 px 高的线，能保持一致的效果。

```html
<div style="height:1px" overflow:hidden; background:red ></div>
```



### 浏览器架构

```
* 用户界面
   * 主进程
   * 内核
       * 渲染引擎
       * JS 引擎
           * 执行栈
       * 事件触发线程
           * 消息队列
               * 微任务
               * 宏任务
       * 网络异步线程
       * 定时器线程
```



### 前端性能优化？

https://juejin.cn/post/6844903657318645767#heading-13

```
前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。

 第一个方面是页面的内容方面

 （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。

 （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。

 （3）通过设置缓存策略，对常用不变的资源进行缓存。

 （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。

 （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。

 第二个方面是服务器方面

 （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。

 （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。

 （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie

 第三个方面是 CSS 和 JavaScript 方面

 （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。

 （2）避免使用 @import 标签。

 （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。

 （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。
```





# CSS

### CSS选择器
- 1000：内联样式
- 100： id选择器
- 10：类选择器（.myclassname）、伪类选择器（a:hover,li:nth-child）、属性选择器（a[rel="external"]）
- 1：标签选择器（div,h1,p）、伪元素选择器（::before、::after）
！import的优先级最高
- 样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。

### CSS中可继承和不可继承属性
#### 可继承
1. display：
2. 盒子模型相关属性
3. 背景属性
4. 定位属性
5. 文本属性
6. 生成内容属性
7. 页面样式属性
#### 不可继承
1. 字体的属性
2. 元素可见性
3. 列表布局属性
4. 光标属性

### display的属性有哪些
1. none
2. block ：默认宽度为父元素宽度 可设置宽高，换行显示
3. inline-block ：默认宽度为内容宽度 可设置宽高 同行显示
4. flex
5. table 此元素会作为块级表格来显示
6. inline 默认宽度为内容宽度 不可设置宽高 同行显示
7. list-item

### requestAnimationframe

window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。

### 隐藏元素的方法有哪些
1. display:none 不会渲染 也不会响应事件 也不占据位置
2. visibility:hidden 仍占据位置 不响应事件
3. opacity:0 透明度为0，只是看不见 其他都响应
4. postion：abosolute 脱离文档流 挪到别的地方
5. z-index 让其他元素覆盖
6. transform: scale(0,0) 将元素缩放为0

### link和@import 区别
- link 是xhtml标签 可以加载CSS之外的资源 并且引入时同时加载 无兼容性问题
- @import 是CSS提出的  会有兼容性问题 只能引入CSS

### transition和animation的区别
- transition是过度动画 需要指定触发事件
- animation是动画属性 不需要触发 设置好时间执行

### 如何判断元素是否到达可视区域
- window.innerHeight 可视高度
- document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动过的距离
- imgs.offsetTop 是元素顶部距离文档顶部的高度

所以文档到达可视区域的时候是通过 imgs.offsetTop<window.innerHeight+document.scrollTop 



### CSS3中有哪些新特性

新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）

- 圆角 （border-radius:8px）

- 多列布局 （multi-column layout）

- 阴影和反射 （Shadoweflect）

- 文字特效 （text-shadow）

- 文字渲染 （Text-decoration）

- 线性渐变 （gradient）

- 旋转 （transform）

- 增加了旋转,缩放,定位,倾斜,动画,多背景



### flex中的属性

[flex布局](https://juejin.cn/post/6844903474774147086)

#### 容器中属性
- flex-direction 决定主轴的方向
- flex-wrap 如何换行
- flex-flow 以上两个的简写形式
- justify-content 主轴方向上的对齐方式
- align-items 交叉轴上如何对齐
- align-content 多行的时候轴线对其方式

#### 项目中属性

- order 项目排列顺序 默认为0 越小越前
- flex-grow 项目放大比例 默认为0
- flex-shrink 项目缩小比例 默认为1
- flex-basis 分配多余空间时占据多少 默认auto
- align-self  align-items属性的专属版本



### BFC 

#### 创建BFC的条件：

- 根元素：body；
- 元素设置浮动：float 除 none 以外的值；
- 元素设置绝对定位：position (absolute、fixed)；
- display 值为：inline-block、table-cell、table-caption、flex等；
- overflow 值为：hidden、auto、scroll；

#### BFC的特点：

- BFC是独立的容器，不会影响容器外部的元素
- BFC区域不会与浮动元素发生重叠
- 计算BFC的高度的时候，要计算浮动元素的高度
- 垂直方向上自上而下的排列，和文档流的排列方式一致

#### BFC的作用：

- 避免两个元素的margin重叠
- 防止浮动后产生的高度塌陷
- 创建自适应的两栏布局



### 元素的层叠顺序

- 背景和边框
- z-index为负的
- 块级盒子
- 行内盒子
- z-index == 0
- z-index > 0 



### **display、float、position的关系**

1. 如果display: none 则postion和float失效
2. 接着看position 是不是 absolute或者fixed 如果是的话float失效     
3. 如果不是absolute或者fixed 则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。

总的来说，可以把它看作是一个类似优先级的机制，"position:absolute"和"position:fixed"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是"none"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。



### absolute与fixed共同点与不同点    以及  sticky的理解

共同点：

1. 都是脱离文档流
2. 都会覆盖非定位元素
3. 改变行内元素的呈现方式，将display设置为Inline-block

不同点：

1. absolute可以设置相对定位的元素(相对于最新的开启了relative/absoluted/fixed) 而fixed是相对于窗口
2. 在有滚动条的页面 fixed就定住了 



### 常见布局的实现方案

1. flex布局 通过flex:1等参数来适配
2. float布局  **float会脱离文档流 但不会脱离文本流**
3. relative 和 absolute 布局

[圣杯布局、双飞翼布局](https://zhuanlan.zhihu.com/p/58355168)

#### 浮动

浮动的定义：

非IE浏览器下，容器**不设高度**且**子元素浮动**时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。

清除浮动的方法：

给父级div定义`height`属性

最后一个浮动元素之后添加一个空的div标签，并添加`clear:both`样式

包含浮动元素的父级标签添加`overflow:hidden`或者`overflow:auto`

使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**





#### 如何解决1px问题

1. 直接写0.5px
2. 伪元素先放大后缩小
3. viewport缩放来解决









# JS



### 为什么0.1+0.2 ! == 0.3，如何让其相等 

可以使用.toFixed(num)



### JavaScript 中如何进行隐式类型转换？

**（1）当**`type`**为**`number`**时规则如下：**

- 调用`obj`的`valueOf`方法，如果为原始值，则返回，否则下一步；
- 调用`obj`的`toString`方法，后续同上；
- 抛出`TypeError` 异常。

**（2）当**`type`**为**`string`**时规则如下：**

- 调用`obj`的`toString`方法，如果为原始值，则返回，否则下一步；
- 调用`obj`的`valueOf`方法，后续同上；
- 抛出`TypeError` 异常





### map和Object的区别

|          | Map                                                          | Object                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 意外的键 | Map默认情况不包含任何键，只包含显式插入的键。                | Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。 |
| 键的类型 | Map的键可以是任意值，包括函数、对象或任意基本类型。          | Object 的键必须是 String 或是Symbol。                        |
| 键的顺序 | Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。 | Object 的键是无序的                                          |
| Size     | Map 的键值对个数可以轻易地通过size 属性获取                  | Object 的键值对个数只能手动计算                              |
| 迭代     | Map 是 iterable 的，所以可以直接被迭代。                     | 迭代Object需要以某种方式获取它的键然后才能迭代。             |
| 性能     | 在频繁增删键值对的场景下表现更好。                           | 在频繁添加和删除键值对的场景下未作出优化。                   |







### map和weakMap的区别

1. Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。

2. WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。



###  JavaScript有哪些内置对象

（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量

（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等

（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等

（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date

（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp

（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array

（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet

（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等

（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等

（10）控制抽象对象 例如 Promise、Generator 等

（11）反射。例如 Reflect、Proxy

（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等

（13）WebAssembly

（14）其他。例如 arguments



### **Unicode、UTF-8、UTF-16、UTF-32有什么区别？**

- `Unicode` 是编码字符集（字符集），而`UTF-8`、`UTF-16`、`UTF-32`是字符集编码（编码规则）；
- `UTF-16` 使用变长码元序列的编码方式，相较于定长码元序列的`UTF-32`算法更复杂，甚至比同样是变长码元序列的`UTF-8`也更为复杂，因为其引入了独特的**代理对**这样的代理机制；
- `UTF-8`需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而`UTF-16`不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；
- 如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用`UTF-8`就比`UTF-16`节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么`UTF-16`就占优势了，可以节省很多空间；







###  for...in和for...of的区别

for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下

- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；
- for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；
- 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；

**总结：** for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。



### 如何使用for...of遍历对象

for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。

如果需要遍历的对象是类数组对象，用Array.from转成数组即可。

如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。



### 什么是尾调用，使用尾调用有什么好处？

1. 尾调用指的是在一个函数的作用域中最后一步调用另外一个函数
2. 好处就是   因为已经是最后一步了，所以就不会保留当前的上下文，节约了内存



### MVC和MVVM

MVC: model view controler

MVVM 本身就是从MVC的设计模式上优化而来的，文章讲的有的复杂，从代码的角度来解析就简单了，
通常MVC的 是我们先获取视图V，然后给这个视图赋予数据M， 这个赋予的过程方法就是C
MVVM呢，就不需要这样了，在vue中我们直接可以先将数据放在view 中V,然后去this.setData （react ：this.setState）M等方法去改变数据，视图随之改变 （VM控制）



### 如何获得对象非原型链上的属性？

```js
function iterate(obj){
   var res=[];
   for(var key in obj){
        if(obj.hasOwnProperty(key)) //使用for in 的同时判断 obj.hasOwnProperty(key)
           res.push(key+': '+obj[key]);
   }
   return res;
} 
```



### 循环中使用闭包解决 var 定义函数的问题

```js
//方法1 使用setTimeout的第三个参数
for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j)
    },
    i * 1000,
    i
  )
}
//方法2 //使用let
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
//方法3 使用闭包
for(var i=1; i<=5 ;i++){
    (
        function(j){
            setTimeout(()=>{
                console.log(j)
            },j*1000)
        }
    )(i)
}
```



### 作用域链

**作用域链：** 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**





### 对执行上下文的理解

执行上下文类型

**（1）全局执行上下文**

任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。

**（2）函数执行上下文**

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。

**（3）**`eval`**函数执行上下文**

执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。



### 并发与并行的区别？

- 并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。
- 并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。





## 小程序

### 区别

1. 提出页面的概念，页面有自己的生命周期，onShow onHide onReady
