## Fenbi-csi

### fenbi-csi 项目概述

`@fenbi/csi` 是一个用于 **跨页面 / 跨站点交互（Cross Site Interaction）** 的前端工具库，主要通过 `window.postMessage` 封装请求-响应机制，简化主页面与子页面（`window.open` / `iframe` / `opener` / `parent` / `top`）之间的异步通信。

### 技术栈与构建

- **语言与类型系统**
  - 使用 **TypeScript** 编写核心代码（`src/*.ts`），通过接口与类型定义保证消息结构和回调的类型安全。
- **打包与构建**
  - 使用 **Webpack 4** 打包，入口为 `src/index.ts`，输出 UMD 格式库：
    - 输出文件：`dist/app.js`
    - 输出格式：`libraryTarget: 'umd'`，便于在多种模块系统中使用。
  - 使用 `ts-loader` 编译 TypeScript。
  - 使用 `tslint` + `tslint-loader` 进行代码风格与质量检查。
- **脚本命令**
  - `npm run build`：调用 `webpack --config build/webpack.config.js` 进行打包。

### 核心功能与模块

- **消息模型（`data/message.ts`）**
  - **`QueryDefer`**：封装一次请求的 `resolve` / `reject` 回调。
  - **`MessageEventData`**：统一消息格式，包含：
    - `__eventName`：事件名 / 方法名
    - `__queryIndex`：请求索引，用于匹配请求与响应
    - `__args`：参数数组
  - **`Handler`**：约定所有处理函数返回 `Promise<T>`，便于异步链路统一处理。

- **`Service`：发起端服务（`helper/service.ts`）**
  - **职责**：在「主页面」一侧使用，负责：
    - 打开新窗口（或由外部传入窗口，如 Electron 中 `openForElectron`）。
    - 向目标窗口发送调用请求，并接收对方回调。
    - 维护请求队列与回调（`queryDefers`）映射。
  - **关键特性**
    - `open(windowOpts?, target?)` / `openForElectron(win)`：初始化目标窗口引用并开始监听 `message` 事件。
    - `initWindow()`：轮询调用远端的 `isInited` 方法，等待子页面准备就绪；在此期间把调用累积在 `initQueryQueue` 中，等初始化完成后统一执行。
    - `exec(method, ...param)`：
      - 在未初始化完成时，将调用排队。
      - 初始化后，通过 `doExec` 实际发送消息。
    - `handle(evtName, callback)`：注册事件处理器，用于响应对方的调用。
    - `onMessage(evt)`：统一处理来自子页面的消息：
      - 如果 `__eventName !== '__callback'`：说明是对方调用本页面注册的 `handler`，执行后将结果再通过 `__callback` 事件回发。
      - 如果 `__eventName === '__callback'`：说明是对某次请求的回包，通过 `__queryIndex` 找到对应的 `QueryDefer` 并调用 `resolve`。
    - `main()`：特殊的「主请求」入口，下标 `0` 对应的请求，用来等待对方返回一个主结果。
    - `getPageHeight()`：示例方法，通过 `exec('pageHeight')` 获取对方页面高度。
    - `close()`：移除监听、清理定时器、关闭窗口。

- **`ServiceProvider`：提供端服务（`helper/serviceProvider.ts`）**
  - **职责**：在「子页面 / 被打开页面」一侧使用，负责：
    - 监听来自 `opener` / `parent` / `top` 的消息。
    - 暴露方法给对方调用。
    - 主动向对方发起调用或回调主请求。
  - **关键特性**
    - `init()`：在子页面中调用：
      - 添加 `window.addEventListener('message')` 监听。
      - 内置一条 `isInited` 处理逻辑，用于让 `Service` 端轮询检查「是否准备完毕」。
    - `getWindow()`：返回 `window.opener || window.parent || window.top` 中与当前窗口不同的那个，用于作为通信对象。
    - `handle(evtName, callback)`：注册可供远端调用的方法。
    - `exec(method, ...param)`：向主页面发送调用请求，并返回 `Promise`。
    - `resolveMain(ret)`：向主页面发送 `__queryIndex: 0` 的 `__callback` 消息，用于完成 `Service.main()` 对应的主请求。
    - `broadcastPageHeight()`：示例方法，计算文档高度后通过 `exec('pageHeight', height)` 广播给对方。

- **`CsiHelper` 入口与导出（`src/index.ts`）**
  - `CsiHelper.createService(url, params?)`：
    - 基于传入 `url` 使用 Node `url` 模块的 `parse` / `format` 追加 query 参数。
    - 自动附加 `sourceUrl = location.href`，方便子页面获知来源页面。
    - 返回一个已绑定指定 URL 的 `Service` 实例。
  - `CsiHelper.createServiceProvider()`：创建一个新的 `ServiceProvider` 实例。
  - 统一导出：
    - `export * from './data/message'`
    - `export { Service as CsiService }`
    - `export { ServiceProvider as CsiServiceProvider }`

### 典型使用场景与流程

- **场景 1：主页面打开子页面并与之交互**
  1. 在主页面：
     - 使用 `CsiHelper.createService(url, params)` 创建 `service`。
     - 调用 `service.open()` 打开子页面窗口并等待初始化。
     - 根据业务需要调用 `service.exec('someMethod', args...)` 或使用封装方法（如 `getPageHeight()`）。
  2. 在子页面：
     - 创建 `const provider = CsiHelper.createServiceProvider()`。
     - 在页面加载完成时调用 `provider.init()`。
     - 使用 `provider.handle('someMethod', async (...args) => { ... })` 注册给主页面调用的异步方法。
     - 需要返回主结果时，可使用 `provider.resolveMain(result)` 对应主页面的 `service.main()`。

- **场景 2：子页面主动向主页面广播信息**
  - 子页面调用 `provider.broadcastPageHeight()`，计算并通过 `postMessage` 把高度发给主页面。
  - 主页面以注册在 `Service` 上的 `handle('pageHeight', ...)` 或对应逻辑来处理该高度信息。

