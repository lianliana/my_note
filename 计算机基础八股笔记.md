### 跨域

#### CORS

CORS响应头部  

 Access-Control-Allow-Origin 

Access-Control-Allow-Headers

Access-Control-Allow-Methods









## 浏览器工作原理

### 浏览器缓存

[资料1](https://blog.csdn.net/huhm_evget/article/details/115749991)

###### 优点

1. 减少冗余的数据传输，节省网络资源，减少服务器负担
2. 提升网站的性能，加快客户端加载网页的速度

图解

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210416145041149.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aG1fZXZnZXQ=,size_16,color_FFFFFF,t_70#pic_center)

##### 缓存分类

- 强缓存

不用请求服务器，直接使用本地缓存，利用http响应头中的Exprires或Cache-Cantrol实现

- 协商缓存

浏览器发现本地有资源的副本，但是不太明确要不要使用，于是去问问服务器。

**优先验证ETag**

| 缓存类型 | 获取资源形式 | 状态码              | 发送请求到服务器                 |
| -------- | ------------ | ------------------- | -------------------------------- |
| 强缓存   | 从缓存取     | 200（from cache）   | 否，直接从缓存取                 |
| 协商缓存 | 从缓存取     | 304（Not Modified） | 否，通过服务器来告知缓存是否可用 |





## 计算机网络



###  GET和POST的请求的区别

Post 和 Get 是 HTTP 请求的两种方法，其区别如下：

- **应用场景：** GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
- **是否缓存：** 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
- **发送的报文格式：** Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
- **安全性：** Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
- **请求长度：** 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
- **参数类型：** post 的参数传递支持更多的数据类型。



### POST和PUT请求的区别

- PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时**更新数据**）
- POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是**创建数据**）



### 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？

（1）**解析URL：** 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）**缓存判断：** 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

（3）**DNS解析：** 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

（4）**获取MAC地址：** 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

（5）**TCP三次握手：** 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

（6）**HTTPS握手：** 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

（7）**返回数据：** 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

（8）**页面渲染：** 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。

（9）**TCP四次挥手：** 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。



### HTTP2的头部压缩算法是怎样的？

HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。



###  HTTP协议的优点和缺点



HTTP协议具有以下**优点**：

支持客户端/服务器模式

**简单快速**：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

**无连接**：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。

**无状态**：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。

**灵活**：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。

HTTP协议具有以下**缺点**：

- **无状态：** HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。
- **明文传输：** 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
- **不安全**













### cookie

客户端在收到Set-Cookie响应后，会在之后每一次请求中带上Cookie字段

关于cookie 

- 要减少Cookie的大小，因为每次请求都会携带Cookie，会造成带宽的浪费
- 为静态组件使用不同的域名
- 减少DNS查询

### Session 

**为了解决Cookie敏感数据的问题** 使用Session

1. 基于Cookie来实现用户和数据的映射，例如将口令放在cookie中，服务端通过cookie中携带的口令来进行查询数据等
2. 通过查询字符串来实现浏览器端和服务端数据的对应 （相当于url中携带口令



#### 请求报文组成

- 请求行
- 请求头（首部）
- 请求体

请求报文由8位组字节流组成

##### 请求行

- 请求方法 url http版本号

##### 响应行

- http版本号 状态码 原因 

##### 请求头

首部包括

- 通用首部字段 
- 请求首部字段
- 响应首部字段
- 实体首部字段

通用首部字段Cache-Control指令

- public：明确表明其他用户也可利用缓存

- private：响应只以特定用户作为对象

- no-cache：目的 为了防止从缓存中返回过期的资源

  若客户端包含 则表示客户端将不会接受缓存过的响应，缓存服务器一定要转发请求给源服务器

  若服务端包含 则表示缓存服务器不能对资源进行缓存

- no-store：暗示请求或响应中包含机密信息

- max-age：根据判断是否过期来决定是否接受缓存的资源

- min-fresh：要求缓存服务器返回至少还未过指定时间的缓存资源

- max-stale：可指示缓存资源，即使过期也照常接受

- only-if-cached：只要缓存服务器中的缓存资源

- must-revalidate：代理回想源服务器再次验证即将返回的缓存资源目前是否仍然有效

- proxy-revalidate：要求所有的缓存服务器在接收到客户端带有该指令的请求返回相应之前，必须再次验证缓存的有效性

- no-transform：缓存不能改变实体主体的媒体类型（防止缓存压缩图片等）

通用首部字段Connect、Update、Date、Via、Transfer-encoding、Tailer



请求首部字段

- Accept

- Authorization:jwt身份校验

- Host:虚拟主机运行在同一个ip上，因此使用首部字段Host加以区别

- Expect

- if-Match

- if-Modified-Since

- If-range

  



##### 常见的状态码

200：请求完整处理

204：请求返回报文没有实体内容 用head请求便是要求响应报文没有响应体

206：范围请求已经完成



301：永久重定向 请求的资源已经被分配到新的URL上了

302：临时重定向 请求的资源被分配到新的URL 希望用户**本次**用新的url，**书签保存的话不会变**

303：See other 请求的资源被分配到新的URL 希望用户用get去请求另一个RUL

304：请求的资源为满足条件 一般是用户请求资源未过期

307：临时重定向 请求方法不得改变

308：永久重定向 请求方法不得改变



400：请求报文中存在语法错误

401：未认证 

403：禁止访问

404：无法找到请求的资源

422：数据发送的格式不对



500：服务器端内部错误

503：服务器目前处于朝服在状态



##### 通信数据转发程序：代理、网关、隧道

###### 代理：

代理是一种由转发功能的应用程序

###### 网关：

网关是转发其他服务器通信数据的服务器

###### 隧道：

在相隔甚远的客户端和服务器两者之间进行中转



##### http 1.1和1.0区别

- 1.1 支持长连接 使多个 http 请求复用同一个 TCP 连接
- http1.1请求头引入了 range 头域，它允许只请求资源的某个部分
- 有了host域，这样就可以将请求发往到同一台服务器上的不同网站
- 增加了一些新的方法如PUT、HEAD、DELETE

##### http1.1和2.0区别

- 服务端推送 http2 下服务器主动推送的是静态资源
- 头部信息压缩 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了
- 二进制编码       在 HTTP/1.1 版中，报文的头信息必须是文本，HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制
- 多路复用    客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞

##### http和https

###### http缺点

- 明文传输，不安全，容易被窃听
- 不验证通信方的身份，可能被伪装
- 无法验证报文的完整性，容易被篡改

SSL 使用的是公开密钥加密

HTTPS使用 公开密钥加密和共享密钥加密混合加密机制



### 网路安全

#### XSS

跨站脚本攻击

###### 解决方案

转义用户输入和校验用户输入 不要信用用户提交的信息

#### CSRF

跨站请求伪造 

###### 解决方案

1. 添加随机值的方式





























## 操作系统

### 线程与进程的比较

线程与进程的比较如下：

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

**线程是调度的基本单位，而进程则是资源拥有的基本单位**。





## 数据库

### 事务

事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：

- **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；
- **一致性（Consistency）**：数据库的完整性不会因为事务的执行而受到破坏，比如表中有一个字段为姓名，它有唯一约束，也就是表中姓名不能重复，如果一个事务对姓名字段进行了修改，但是在事务提交后，表中的姓名变得非唯一性了，这就破坏了事务的一致性要求，这时数据库就要撤销该事务，返回初始化的状态。
- **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
- **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。

- 脏读：读到其他事务未提交的数据；
- 不可重复读：前后读取的数据不一致；
- 幻读：前后读取的记录数量不一致。

![图片](https://img-blog.csdnimg.cn/img_convert/d37bfa1678eb71ae7e33dc8f211d1ec1.png)

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（\*repeatable read\*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

![图片](https://img-blog.csdnimg.cn/img_convert/4e98ea2e60923b969790898565b4d643.png)



