### 跨域

#### CORS

CORS响应头部  

 Access-Control-Allow-Origin 

Access-Control-Allow-Headers

Access-Control-Allow-Methods









## 浏览器工作原理

### 浏览器缓存

[资料1](https://blog.csdn.net/huhm_evget/article/details/115749991)

###### 优点

1. 减少冗余的数据传输，节省网络资源，减少服务器负担
2. 提升网站的性能，加快客户端加载网页的速度

图解

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210416145041149.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aG1fZXZnZXQ=,size_16,color_FFFFFF,t_70#pic_center)

##### 缓存分类

- 强缓存

不用请求服务器，直接使用本地缓存，利用http响应头中的Exprires或Cache-Cantrol实现

- 协商缓存

浏览器发现本地有资源的副本，但是不太明确要不要使用，于是去问问服务器。

**优先验证ETag**

| 缓存类型 | 获取资源形式 | 状态码              | 发送请求到服务器                 |
| -------- | ------------ | ------------------- | -------------------------------- |
| 强缓存   | 从缓存取     | 200（from cache）   | 否，直接从缓存取                 |
| 协商缓存 | 从缓存取     | 304（Not Modified） | 否，通过服务器来告知缓存是否可用 |





## 计算机网络

### cookie

客户端在收到Set-Cookie响应后，会在之后每一次请求中带上Cookie字段

关于cookie 

- 要减少Cookie的大小，因为每次请求都会携带Cookie，会造成带宽的浪费
- 为静态组件使用不同的域名
- 减少DNS查询

### Session 

**为了解决Cookie敏感数据的问题** 使用Session

1. 基于Cookie来实现用户和数据的映射，例如将口令放在cookie中，服务端通过cookie中携带的口令来进行查询数据等
2. 通过查询字符串来实现浏览器端和服务端数据的对应 （相当于url中携带口令



#### 请求报文组成

- 请求行
- 请求头（首部）
- 请求体

请求报文由8位组字节流组成

##### 请求行

- 请求方法 url http版本号

##### 响应行

- http版本号 状态码 原因 

##### 请求头

首部包括

- 通用首部字段 
- 请求首部字段
- 响应首部字段
- 实体首部字段

通用首部字段Cache-Control指令

- public：明确表明其他用户也可利用缓存

- private：响应只以特定用户作为对象

- no-cache：目的 为了防止从缓存中返回过期的资源

  若客户端包含 则表示客户端将不会接受缓存过的响应，缓存服务器一定要转发请求给源服务器

  若服务端包含 则表示缓存服务器不能对资源进行缓存

- no-store：暗示请求或响应中包含机密信息

- max-age：根据判断是否过期来决定是否接受缓存的资源

- min-fresh：要求缓存服务器返回至少还未过指定时间的缓存资源

- max-stale：可指示缓存资源，即使过期也照常接受

- only-if-cached：只要缓存服务器中的缓存资源

- must-revalidate：代理回想源服务器再次验证即将返回的缓存资源目前是否仍然有效

- proxy-revalidate：要求所有的缓存服务器在接收到客户端带有该指令的请求返回相应之前，必须再次验证缓存的有效性

- no-transform：缓存不能改变实体主体的媒体类型（防止缓存压缩图片等）

通用首部字段Connect、Update、Date、Via、Transfer-encoding、Tailer



请求首部字段

- Accept

- Authorization:jwt身份校验

- Host:虚拟主机运行在同一个ip上，因此使用首部字段Host加以区别

- Expect

- if-Match

- if-Modified-Since

- If-range

  



##### 常见的状态码

200：请求完整处理

204：请求返回报文没有实体内容 用head请求便是要求响应报文没有响应体

206：范围请求已经完成



301：永久重定向 请求的资源已经被分配到新的URL上了

302：临时重定向 请求的资源被分配到新的URL 希望用户**本次**用新的url，**书签保存的话不会变**

303：See other 请求的资源被分配到新的URL 希望用户用get去请求另一个RUL

304：请求的资源为满足条件 一般是用户请求资源未过期

307：临时重定向 请求方法不得改变

308：永久重定向 请求方法不得改变



400：请求报文中存在语法错误

401：未认证 

403：禁止访问

404：无法找到请求的资源

422：数据发送的格式不对



500：服务器端内部错误

503：服务器目前处于朝服在状态



##### 通信数据转发程序：代理、网关、隧道

###### 代理：

代理是一种由转发功能的应用程序

###### 网关：

网关是转发其他服务器通信数据的服务器

###### 隧道：

在相隔甚远的客户端和服务器两者之间进行中转

##### http 1.1和1.0区别

- 1.1 支持长连接
- 废弃了link unlink 方法
- 有了host域

##### http和https

###### http缺点

- 明文传输，不安全，容易被窃听
- 不验证通信方的身份，可能被伪装
- 无法验证报文的完整性，容易被篡改

SSL 使用的是公开密钥加密

HTTPS使用 公开密钥加密和共享密钥加密混合加密机制



### 网路安全

#### XSS

跨站脚本攻击

###### 解决方案

转义用户输入和校验用户输入 不要信用用户提交的信息

#### CSRF

跨站请求伪造 

###### 解决方案

1. 添加随机值的方式





























## 操作系统

### 线程与进程的比较

线程与进程的比较如下：

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

**线程是调度的基本单位，而进程则是资源拥有的基本单位**。





## 数据库

### 事务

事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：

- **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；
- **一致性（Consistency）**：数据库的完整性不会因为事务的执行而受到破坏，比如表中有一个字段为姓名，它有唯一约束，也就是表中姓名不能重复，如果一个事务对姓名字段进行了修改，但是在事务提交后，表中的姓名变得非唯一性了，这就破坏了事务的一致性要求，这时数据库就要撤销该事务，返回初始化的状态。
- **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
- **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。

- 脏读：读到其他事务未提交的数据；
- 不可重复读：前后读取的数据不一致；
- 幻读：前后读取的记录数量不一致。

![图片](https://img-blog.csdnimg.cn/img_convert/d37bfa1678eb71ae7e33dc8f211d1ec1.png)

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（\*repeatable read\*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

![图片](https://img-blog.csdnimg.cn/img_convert/4e98ea2e60923b969790898565b4d643.png)



