### 跨域

#### CORS

CORS响应头部  

 Access-Control-Allow-Origin 

Access-Control-Allow-Headers

Access-Control-Allow-Methods









## 浏览器工作原理

### 浏览器缓存

[资料1](https://blog.csdn.net/huhm_evget/article/details/115749991)

###### 优点

1. 减少冗余的数据传输，节省网络资源，减少服务器负担
2. 提升网站的性能，加快客户端加载网页的速度

图解

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210416145041149.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1aG1fZXZnZXQ=,size_16,color_FFFFFF,t_70#pic_center)

##### 缓存分类

- 强缓存

不用请求服务器，直接使用本地缓存，利用http响应头中的Exprires或Cache-Cantrol实现

- 协商缓存

浏览器发现本地有资源的副本，但是不太明确要不要使用，于是去问问服务器。

**优先验证ETag**

| 缓存类型 | 获取资源形式 | 状态码              | 发送请求到服务器                 |
| -------- | ------------ | ------------------- | -------------------------------- |
| 强缓存   | 从缓存取     | 200（from cache）   | 否，直接从缓存取                 |
| 协商缓存 | 从缓存取     | 304（Not Modified） | 否，通过服务器来告知缓存是否可用 |





## 计算机网络

### cookie

客户端在收到Set-Cookie响应后，会在之后每一次请求中带上Cookie字段

关于cookie 

- 要减少Cookie的大小，因为每次请求都会携带Cookie，会造成带宽的浪费
- 为静态组件使用不同的域名
- 减少DNS查询

### Session 

**为了解决Cookie敏感数据的问题** 使用Session

1. 基于Cookie来实现用户和数据的映射，例如将口令放在cookie中，服务端通过cookie中携带的口令来进行查询数据等
2. 通过查询字符串来实现浏览器端和服务端数据的对应 （相当于url中携带口令



### 网路安全

#### XSS

跨站脚本攻击

###### 解决方案

转义用户输入和校验用户输入 不要信用用户提交的信息

#### CSRF

跨站请求伪造 

###### 解决方案

1. 添加随机值的方式





























## 操作系统

### 线程与进程的比较

线程与进程的比较如下：

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；

**线程是调度的基本单位，而进程则是资源拥有的基本单位**。





## 数据库

### 事务

事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：

- **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样；
- **一致性（Consistency）**：数据库的完整性不会因为事务的执行而受到破坏，比如表中有一个字段为姓名，它有唯一约束，也就是表中姓名不能重复，如果一个事务对姓名字段进行了修改，但是在事务提交后，表中的姓名变得非唯一性了，这就破坏了事务的一致性要求，这时数据库就要撤销该事务，返回初始化的状态。
- **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
- **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。

- 脏读：读到其他事务未提交的数据；
- 不可重复读：前后读取的数据不一致；
- 幻读：前后读取的记录数量不一致。

![图片](https://img-blog.csdnimg.cn/img_convert/d37bfa1678eb71ae7e33dc8f211d1ec1.png)

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（\*repeatable read\*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

![图片](https://img-blog.csdnimg.cn/img_convert/4e98ea2e60923b969790898565b4d643.png)



