### 2026.1.26 京东金融一面



##### 设计模式讲一讲

前端常用设计模式（简短版）

**创建型**
- **单例（Singleton）**：全局唯一实例（全局配置、埋点 SDK、WebSocket 管理、缓存管理器）
- **工厂（Factory）**：按类型/参数创建不同对象或组件（表单项渲染、弹窗/图标组件选择）

**结构型**

- **装饰器（Decorator）**：不改原逻辑叠加能力（日志、性能统计、重试/缓存/节流包装）
- **代理（Proxy）**：控制/增强访问（Vue3 响应式思路、鉴权、懒加载、Mock 代理）
- **适配器（Adapter）**：抹平接口差异（后端字段兼容、多家 SDK 统一接口）
- **外观（Facade）**：提供统一入口屏蔽复杂性（统一 `request()`、`track()`、`storage` 封装）
- **组合（Composite）**：树结构一致处理（菜单/路由树、权限树、配置树）

**行为型**
- **观察者/发布订阅（Observer/Pub-Sub）**：事件驱动解耦（事件总线、状态变更通知）
- **策略（Strategy）**：可替换规则/算法（校验规则、不同端/业务展示策略）
- **责任链（Chain）**：层层处理直到结束（中间件、axios 拦截器、路由守卫）
- **状态（State）**：状态不同表现/行为不同（加载/空/错 UI，订单/审核流程）
- **命令（Command）**：操作可记录与撤销/重做（富文本、画布/流程图、快捷键系统）

##### 如何实现碰撞检测

**核心思路**：先做“粗检测”快速筛掉大部分不可能碰撞的对象，再对候选对做“精检测”。

**1）粗检测（Broad Phase）**
- **包围盒/包围圆**：先用 AABB（轴对齐包围盒）或圆做快速判断
- **空间划分/加速结构**：避免 \(O(n^2)\)
  - **均匀网格（Spatial Hash/Grid）**：2D 游戏/大量移动物体常用
  - **四叉树（Quadtree）**：分布不均匀时效果更好
  - **Sweep and Prune**：按轴排序，检测重叠区间

**2）精检测（Narrow Phase）**
- **AABB vs AABB（矩形）**：判断 x/y 轴投影是否重叠  
  - 不分离即碰撞：`ax1 <= bx2 && ax2 >= bx1 && ay1 <= by2 && ay2 >= by1`
- **圆 vs 圆**：中心距离平方 \(\le (r1+r2)^2\)
- **圆 vs AABB**：圆心到矩形的最近点距离（把圆心 clamp 到矩形内/边界）
- **OBB/多边形**：用 **SAT（分离轴定理）**，若存在一条分离轴则不碰撞

**3）工程优化点（面试加分）**
- **只在“同一网格/同一层级”内两两检测**，候选集越小越快
- **用平方距离避免开方**；能用整数就用整数
- **时间步长**：高速运动用 CCD（连续碰撞检测）避免“穿透”（如射线/扫掠体）
- **返回更多信息**：不仅要 yes/no，通常还要碰撞法线、穿透深度用于反弹/分离





##### Nest的特点以及和Express和Koa的区别

**Nest 相比 Express/Koa**

- **工程化/约定优于配置**：Controller/Service/Module 分层清晰，适合中大型项目
- **DI + 模块化**：依赖注入解耦，便于复用与单测
- **TS 一等公民 + 装饰器**：声明式路由/鉴权/校验等，统一做横切能力（拦截器/管道/过滤器）
- **生态更全**：Swagger、WebSocket、微服务等有成熟方案（底层可用 Express/Fastify）
- **AOP 能力齐全**：Guard（鉴权）/Interceptor（日志缓存转换）/Pipe（参数解析+校验）/Filter（统一异常）
- **统一规范更容易落地**：DTO + class-validator、全局异常/响应格式、全局日志/链路追踪
- **可测试性更好**：DI 容器天然支持 Mock，e2e/单测体系更顺
- **平台抽象**：HTTP 适配 Express/Fastify，业务代码更不绑底层；也能扩到 GraphQL/WS
- **适用场景**：团队协作、业务复杂、需要统一规范/微服务/WS 的项目更合适

**Nest 这套 Guard / Pipe / Interceptor / Filter 分别干啥（面试常问）**
- **Guard（守卫）**：决定“能不能进”——**鉴权/权限/登录态**（返回 true/false 或抛异常）。典型：JWT 校验、RBAC 权限、接口级别白名单。
- **Pipe（管道）**：解决“参数怎么变得可用”——**参数解析 + 校验 + 转换**。典型：把 query/path/body 转成 DTO；`class-validator` 校验不通过直接 400；把 `"123"` 转成 number。
- **Interceptor（拦截器）**：解决“进来/出去都要做点事”——**环绕增强（before + after）**，最像 AOP/洋葱。典型：日志与耗时统计、统一响应包装、缓存（读/写）、对返回值做 map/transform。
- **Filter（异常过滤器）**：解决“错了怎么统一处理”——**统一兜底异常**，把各种 throw 出来的错误转成统一的 HTTP 响应格式（状态码、message、errorCode、traceId 等）。

**一次 HTTP 请求在 Nest 里的典型流程（从进到出）**
- **入站（request）**：Middleware（底层 Express/Fastify 中间件） → Guard（能不能进） → Interceptor（before，打点/日志等） → Pipe（解析/校验/转换参数） → Controller/RouteHandler → Service/DB…
- **出站（response）**：Interceptor（after，对返回值做包装/缓存写入等） → 返回给客户端
- **异常分支**：中间任意环节 throw/抛错 → **Exception Filter** 接管 → 生成统一错误响应

**补充：顺序细节（背一句就够）**
- 同一种组件如果同时有 **全局 / 模块 / Controller / 路由** 多层配置，通常是“越靠近路由越具体”，执行上会按框架规则叠加；对 Interceptor 这种环绕逻辑，**返回阶段会反向回溯**（更像洋葱）。

**Express vs Koa**
- **中间件模型**：Express 线性 `req,res,next`；Koa `async/await` 洋葱模型 `await next()`
- **内置程度**：Express 更“开箱即用”；Koa 更轻更自由（更多靠社区中间件组合）
- **上下文**：Express 以 `req/res` 为主；Koa 以 `ctx` 聚合 request/response





##### proseMirror怎么实现图文混排的，还有prosemirror原理

- **图文混排本质**：把“图片/视频/卡片”等当成文档里的 **Node**（和 text node 并列），进入同一套文档结构与文档流；inline/block 决定它是“像字符一样夹在文字里”还是“独占一行”。
- **Schema 控制渲染/交互**：定义 `image` 节点（`inline`/`group` 决定能出现的位置），`atom: true` 让它变成“不可拆分的原子”（光标不进内部，整体选中/删除更自然）；`attrs` 存 `src/alt/width/height` 等。
- **核心原理（以 doc 为中心）**：初始化/粘贴时 **DOM/HTML → DOMParser.fromSchema(schema)** 按 `parseDOM` 解析成 `state.doc`；展示时 **doc → toDOM/NodeView** 渲染为 DOM，`EditorView` 维护 doc 位置（pos）与 DOM 的映射，编辑通过 transaction 更新 doc，再增量更新 DOM。
- **图片大小控制**：简单统一用 CSS（如 `max-width:100%; height:auto`）；要“可持久化可协同”的大小用 `attrs.width/height`，渲染到 DOM（`style/width/height`）；拖拽 resize 一般用 NodeView + transaction（`setNodeMarkup`）更新 attrs。

##### qiankun 怎么用 & 简单原理
- **qiankun 是啥**：基于 single-spa 的微前端框架/调度器（注册子应用、路由激活、沙箱/隔离、资源加载）。
- **entry 是啥**：不是“UMD/ESM 产物类型”，而是“从哪开始加载”——最常见是 **HTML Entry**（`entry` 给一个 URL，先拉 HTML，再解析 `<script>/<link>` 加载资源）；**JS Entry** 更少见（入口就是一段 JS/函数，直接执行拿到生命周期）。
- **生命周期怎么用**：qiankun 加载并执行子应用脚本后拿到 `{ bootstrap, mount, unmount, update }` 并缓存；首次进入 `bootstrap` 只调用一次，之后每次进入调用 `mount(props)`，切出调用 `unmount(props)`（`update` 主要在 `loadMicroApp` 场景）。
- **子应用标准写法**：不要在入口顶层 `root.render()`；把渲染放在 `mount(props)`（挂到 `props.container`），卸载放 `unmount`；独立运行用 `window.__POWERED_BY_QIANKUN__` 分支自行 render。
- **分包/主 chunk 怎么办**：分包通常没问题；“入口脚本”由子应用 `index.html` 里的 `<script>` 决定（不是 qiankun 猜的），后续 chunk 由 webpack/vite 运行时按 `import()` 关系加载；重点注意 **publicPath/base** 配置，否则动态 chunk 可能 404/跑到主应用域名下。





##### Nest 装饰器怎么用 & reflect-metadata 在 Nest 里怎么用（面试版）

---

**一、Nest 装饰器都是怎么用的？（看得懂就能写 Controller）**

**1）`@Controller()`：给一组路由加前缀**

- `@Controller('users')` 表示这个类下面的所有路由都以 `/users` 开头
- 本质：把“路由前缀”等信息写到 metadata 里，Nest 启动时扫描并注册路由

**2）`@Get()`/`@Post()`：把方法注册成路由**

- `@Get()`：GET `/users`
- `@Get(':id')`：GET `/users/:id`
- `@Post()`：POST `/users`
- 本质：方法级 metadata（HTTP method + path），Nest 启动时读取后生成路由映射表

**3）`@Param()`/`@Query()`/`@Body()`：把请求数据“注入到参数”**

- `@Param('id') id: string`：取路径参数 `/users/:id` 的 `id`
- `@Query('page') page: string`：取 querystring `?page=1`
- `@Body() dto: CreateUserDto`：取请求体（POST/PUT 常用）
- 本质：参数装饰器把“第几个参数要取哪块数据”的规则写入 metadata，请求到来时由 Pipe/参数解析器按规则组装参数

**4）常见组合（面试说清楚就行）**

- `@UseGuards(AuthGuard)`：鉴权（能不能进）
- `@UsePipes(ValidationPipe)`：参数校验/转换
- `@UseInterceptors(LoggingInterceptor)`：环绕增强（日志/耗时/响应包装/缓存）
- `@UseFilters(HttpExceptionFilter)`：异常统一处理

**一句话总结**：Nest 的装饰器主要做两件事：  
- **声明式路由**（Controller + Method）  
- **声明式参数注入/横切能力**（Param/Body/Guards/Pipes/Interceptors/Filters）  
底层机制：**写元数据 → Nest 在启动/请求时读取元数据并执行对应逻辑**。

---

**二、`Reflect.defineMetadata` / `Reflect.getMetadata` 在 Nest 里到底怎么用？**

> 你在业务里通常不会直接写 `Reflect.defineMetadata/getMetadata`，Nest 提供了更顺手的封装：  
> **写：`SetMetadata()`（底层就是 defineMetadata）**  
> **读：`Reflector`（底层就是 getMetadata，并帮你做“方法优先、其次类”）**

**1）写元数据：`SetMetadata`（= defineMetadata）**

典型：做一个 `@Roles('admin')` 装饰器

```ts
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

**2）读元数据：`Reflector`（= getMetadata）**

在 Guard 里读取：先看方法，再看类（Nest 推荐写法）

```ts
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from './roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(ctx: ExecutionContext) {
    const roles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [
      ctx.getHandler(), // 方法
      ctx.getClass(),   // 类
    ]);
    if (!roles) return true;
    // ...再结合 ctx.switchToHttp().getRequest().user 做 RBAC 判断
    return true;
  }
}
```

**3）再举一个面试常用：`@Public()` 跳过鉴权**

```ts
import { SetMetadata } from '@nestjs/common';
export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
```

Guard 里：
- `isPublic === true` → 直接放行
- 否则走 JWT 校验

**一句话总结（背这句）**：  
- Nest 装饰器绝大多数时候就是 **“写 metadata”**；  
- Guard/Interceptor/Pipe 在运行时用 **Reflector（读 metadata）** 决定要不要执行某段逻辑；  
- `SetMetadata` 和 `Reflector` 的底层分别就是 `Reflect.defineMetadata` / `Reflect.getMetadata` 这一套。
